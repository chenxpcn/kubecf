#!/usr/bin/env tclsh
## Given a path to a file holding a list of events, as generated by
## the `upwatch` tool, convert the events found in the file into a
## diagram visualizing their sequencing. The result is written to
## stdout. The diagram/image format is SVG (scalable vector graphics).

proc main {} {
    cmdline
    ingest
    process
    emit
}

proc cmdline {} {
    global argv
    if {[llength $argv] != 1} usage
    global changes
    set changes [lindex $argv 0]
}

proc usage {} {
    global argv0
    puts stderr "Usage: $argv0 path"
    exit 1
}

proc ingest {} {
    global changes
    set changes [open $changes r]
    set changes [split [string trim [read $changes][close $changes]] \n]
    return
}

proc process {} {
    global changes dia xmax ymax note height
    set height 20
    set base [lindex $changes 0 1]
    set xmax {}

    array set note {}
    array set s {}
    foreach change $changes {
	lassign $change _ stamp state ig
	set x [expr {$stamp - $base}]
	lappend s($ig) [list $state $x . . $height]
	#                placeholders: y w 
	set note($ig) $x
	set xmax $x
    }

    # s   : ig -> list (tuple(state x y w h))
    # note : ig -> (max x)

    set gs [lmap ig [array names s] {
	list $note($ig) $ig
    }]

    array set dia {}
    foreach el [lsort -dict $gs] {
	lassign $el _ ig
	incr y $height

	set actions $s($ig)
	set xn [expr {$note($ig) + 5}]
	set t  [list . $xn . . .]
	set sa [lrange [linsert $actions end $t] 1 end]

	set note($ig) $y
	set dia($ig) [lmap c $actions n $sa {
	    lassign $c state x  _ _ height
	    lassign $n _     nx _ _ _
	    set w [expr {$nx - $x}]
	    list $state $x $y $w $height
	}]
    }
    set ymax $y
    return
}

proc emit {} {
    global dia note height
    head
    foreach ig [array names dia] {
	foreach el $dia($ig) {
	    lassign $el _ x _ w _
	    box {*}$el
	    set e [expr {$x + $w}]
	}
	text $ig [expr {$e + 2}] [expr {$height/2 + $note($ig)}]
    }
    tail
}

proc head {} {
    global xmax ymax height
    incr xmax 100 ;# give space to the (last) text for ig's, to the right
    incr ymax $height ;# give space to the last row, down
    incr ymax $height
    puts "<svg width='$xmax' height='$ymax' xmlns='http://www.w3.org/2000/svg'>"
    box "<BG>" 0 0 $xmax $ymax
    return
}

proc tail {} { puts "</svg>" }

proc text {text x y} {
    puts "<text x='$x' y='$y'>$text</text>"
}

proc box {text x y w h} {
    set c [color $text]

    if {1||[string match Init:* $text]} { set text "" }

    # fill-opacity:0.1
    puts "<rect x='$x' y='$y' width='$w' height='$h' style='fill:$c;stroke:black'/>"

    if {$text eq {}} return
    text $text $x $y
    return
}

proc color {t} {
    if {[string match Init:* $t]} { return lightblue }
    if {[string match Run:*  $t]} { return yellow }
    return [dict get {
	{<BG>} white
	Pending           yellow
	PodInitializing   yellow
	ContainerCreating yellow
	Error             red
	CrashLoopBackOff  orange
	Init:CrashLoopBackOff orange
	Ready             green
	Completed         green
	Terminating       orange
    } $t]
}

main
exit
